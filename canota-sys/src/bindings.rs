/* automatically generated by rust-bindgen 0.59.2 */

pub type __u8 = ::std::os::raw::c_uchar;
pub type __u32 = ::std::os::raw::c_uint;
pub type canid_t = __u32;
#[repr(C)]
#[repr(align(8))]
#[derive(Debug, Copy, Clone)]
pub struct can_frame {
    pub can_id: canid_t,
    pub can_dlc: __u8,
    pub __pad: __u8,
    pub __res0: __u8,
    pub __res1: __u8,
    pub data: [__u8; 8usize],
}
#[test]
fn bindgen_test_layout_can_frame() {
    assert_eq!(
        ::std::mem::size_of::<can_frame>(),
        16usize,
        concat!("Size of: ", stringify!(can_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<can_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(can_frame))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).can_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(can_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).can_dlc as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(can_dlc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).__pad as *const _ as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(__pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).__res0 as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(__res0)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).__res1 as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(__res1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<can_frame>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(can_frame),
            "::",
            stringify!(data)
        )
    );
}
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pollfd {
    pub fd: ::std::os::raw::c_int,
    pub events: ::std::os::raw::c_short,
    pub revents: ::std::os::raw::c_short,
}
#[test]
fn bindgen_test_layout_pollfd() {
    assert_eq!(
        ::std::mem::size_of::<pollfd>(),
        8usize,
        concat!("Size of: ", stringify!(pollfd))
    );
    assert_eq!(
        ::std::mem::align_of::<pollfd>(),
        4usize,
        concat!("Alignment of ", stringify!(pollfd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).events as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pollfd>())).revents as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(pollfd),
            "::",
            stringify!(revents)
        )
    );
}
pub const canota_mode_CANOTA_MODE_APPLICATION: canota_mode = 0;
pub const canota_mode_CANOTA_MODE_BOOTLOADER: canota_mode = 1;
pub const canota_mode_CANOTA_MODE_RESET_ONLY: canota_mode = 255;
pub type canota_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canota_device_ctx {
    pub ctx: *mut canota_ctx,
    pub device_id: u32,
    pub short_device_id: u8,
    pub mode: canota_mode,
    pub info: canota_device_ctx__bindgen_ty_1,
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct canota_device_ctx__bindgen_ty_1 {
    pub device_type: u8,
    pub version_minor: u8,
    pub version_major: u8,
    pub reserved0: u8,
}
#[test]
fn bindgen_test_layout_canota_device_ctx__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<canota_device_ctx__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(canota_device_ctx__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<canota_device_ctx__bindgen_ty_1>(),
        1usize,
        concat!("Alignment of ", stringify!(canota_device_ctx__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<canota_device_ctx__bindgen_ty_1>())).device_type as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx__bindgen_ty_1),
            "::",
            stringify!(device_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<canota_device_ctx__bindgen_ty_1>())).version_minor as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx__bindgen_ty_1),
            "::",
            stringify!(version_minor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<canota_device_ctx__bindgen_ty_1>())).version_major as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx__bindgen_ty_1),
            "::",
            stringify!(version_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<canota_device_ctx__bindgen_ty_1>())).reserved0 as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx__bindgen_ty_1),
            "::",
            stringify!(reserved0)
        )
    );
}
#[test]
fn bindgen_test_layout_canota_device_ctx() {
    assert_eq!(
        ::std::mem::size_of::<canota_device_ctx>(),
        24usize,
        concat!("Size of: ", stringify!(canota_device_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<canota_device_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(canota_device_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_device_ctx>())).ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx),
            "::",
            stringify!(ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_device_ctx>())).device_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx),
            "::",
            stringify!(device_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<canota_device_ctx>())).short_device_id as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx),
            "::",
            stringify!(short_device_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_device_ctx>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_device_ctx>())).info as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_device_ctx),
            "::",
            stringify!(info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct canota_ctx {
    pub can_fd: ::std::os::raw::c_int,
    pub can_pollfd: pollfd,
    pub timeout: u32,
    pub write_delay: u32,
}
#[test]
fn bindgen_test_layout_canota_ctx() {
    assert_eq!(
        ::std::mem::size_of::<canota_ctx>(),
        20usize,
        concat!("Size of: ", stringify!(canota_ctx))
    );
    assert_eq!(
        ::std::mem::align_of::<canota_ctx>(),
        4usize,
        concat!("Alignment of ", stringify!(canota_ctx))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_ctx>())).can_fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_ctx),
            "::",
            stringify!(can_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_ctx>())).can_pollfd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_ctx),
            "::",
            stringify!(can_pollfd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_ctx>())).timeout as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_ctx),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<canota_ctx>())).write_delay as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(canota_ctx),
            "::",
            stringify!(write_delay)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mask_match {
    pub mask: u32,
    pub match_: u32,
}
#[test]
fn bindgen_test_layout_mask_match() {
    assert_eq!(
        ::std::mem::size_of::<mask_match>(),
        8usize,
        concat!("Size of: ", stringify!(mask_match))
    );
    assert_eq!(
        ::std::mem::align_of::<mask_match>(),
        4usize,
        concat!("Alignment of ", stringify!(mask_match))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mask_match>())).mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_match),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<mask_match>())).match_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mask_match),
            "::",
            stringify!(match_)
        )
    );
}
extern "C" {
    pub fn canota_init(iface: *const ::std::os::raw::c_char) -> *mut canota_ctx;
}
extern "C" {
    pub fn canota_device_from_short_id(ctx: *mut canota_ctx, id: u8) -> *mut canota_device_ctx;
}
extern "C" {
    #[must_use]
    pub fn canota_raw_cmd(
        dev: *mut canota_device_ctx,
        cmd: u8,
        param: u8,
        data: *mut ::std::os::raw::c_void,
        len: u8,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_raw_recv_frame(
        ctx: *mut canota_ctx,
        frame: *mut can_frame,
        matches: *mut mask_match,
        nmatches: size_t,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_raw_recv(
        dev: *mut canota_device_ctx,
        cmd: u8,
        param: *mut u8,
        data: *mut ::std::os::raw::c_void,
        len: *mut u8,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_raw_recv_and_status(
        dev: *mut canota_device_ctx,
        cmd: u8,
        param: *mut u8,
        data: *mut ::std::os::raw::c_void,
        len: *mut u8,
        status: *mut u8,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_device_ident_req(dev: *mut canota_device_ctx) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_mode_switch(dev: *mut canota_device_ctx, mode: canota_mode) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_change_short_id(dev: *mut canota_device_ctx, new_id: u8) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_flash_erase(dev: *mut canota_device_ctx, start_addr: u32, len: u32) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_flash_checksum(
        dev: *mut canota_device_ctx,
        start_addr: u32,
        len: u32,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_flash_buffer_write_data(
        dev: *mut canota_device_ctx,
        data: *mut ::std::os::raw::c_void,
        offset: u8,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_cmd_flash_buffer_commit(
        dev: *mut canota_device_ctx,
        addr: u32,
        checksum: u32,
        len: u8,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_device_ident_update(dev: *mut canota_device_ctx) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_mode_switch(dev: *mut canota_device_ctx, mode: canota_mode) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_change_short_id(dev: *mut canota_device_ctx, new_short_id: u8) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_flash(
        dev: *mut canota_device_ctx,
        start_addr: u32,
        data: *mut ::std::os::raw::c_void,
        len: u32,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_checksum(
        dev: *mut canota_device_ctx,
        checksum_start: u32,
        checksum_len: u32,
        checksum_out: *mut u32,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_flash_erase(
        dev: *mut canota_device_ctx,
        erase_start: u32,
        erase_len: u32,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_flash_write_page(
        dev: *mut canota_device_ctx,
        data: *mut ::std::os::raw::c_void,
        data_len: u32,
        addr: u32,
    ) -> bool;
}
extern "C" {
    #[must_use]
    pub fn canota_flash_write(
        dev: *mut canota_device_ctx,
        data: *mut ::std::os::raw::c_void,
        len: u32,
        start_addr: u32,
    ) -> bool;
}
