use super::super::worker_states::*;
use super::super::messages::*;
use super::super::main_loop::*;
use crate::board_states::{BoardStates};
use crate::pod_states::PodState;
use std::sync::mpsc::{ Receiver, Sender };
use std::time::{Duration, Instant};
use std::convert::TryInto;
use socketcan::ShouldRetry;
use crate::can_extentions::prelude::*;
use crate::can_extentions::ack_nack::AckNack;


#[repr(C)] //* Required for type transmutations
pub struct CanWorker<State = Startup> {
    // can_interface: String,
    can_handle: socketcan::CANSocket,
    udp_sender: Sender<UDPMessage>,
    worker_sender: Sender<WorkerMessage>,
    can_receiver: Receiver<CanMessage>,
    requested_pod_state: PodState,
    current_pod_state: PodState,
    board_state: BoardStates,
    last_send: Instant,
    state: std::marker::PhantomData<State>
}

pub struct CanWorkerInitializer {
    pub can_interface: String,
    pub udp_message_sender: Sender<UDPMessage>,
    pub worker_message_sender: Sender<WorkerMessage>,
    pub can_message_receiver: Receiver<CanMessage>,
    pub can_socket_read_timeout: Duration
}

impl CanWorker {
    pub fn new(
        initializer: CanWorkerInitializer
    ) -> CanWorker<Disconnected> {
        let can_handle = socketcan::CANSocket::open(&initializer.can_interface).expect(&format!("Unable to Connect to CAN interface: {}", initializer.can_interface));
        can_handle.set_read_timeout(initializer.can_socket_read_timeout).expect("Unable to Set Timeout on CAN Socket");
        CanWorker {
            can_handle,
            udp_sender: initializer.udp_message_sender,
            worker_sender: initializer.worker_message_sender,
            can_receiver: initializer.can_message_receiver,
            requested_pod_state: PodState::LowVoltage,
            current_pod_state: PodState::LowVoltage,
            board_state: BoardStates::default(),
            last_send: Instant::now(),
            state: std::marker::PhantomData
        }
    }
}

pub type CanWorkerState = WorkerState<CanWorker<Startup>, CanWorker<Recovery>, CanWorker<Connected>, CanWorker<Disconnected>>;

impl CanWorkerState {
    pub fn new(
        initializer: CanWorkerInitializer
    ) -> CanWorkerState {
        CanWorkerState::Disconnected(CanWorker::new(initializer))
    }
}

/**
 * The CanWorker is not as complicated as the Udp or tcp worker. It only implments one
 * mainloop and does not transition between main loops. It's main goal is to read
 * messages being received on the can bus and forward them to the worker as well as to
 * send transision requests which are generated by the UDP controller.
 */
impl MainLoop<CanWorkerState> for CanWorker<Startup> {
    fn main_loop(self) -> CanWorkerState {
       panic!("CanWorker does not implement startup");
    }
}
impl MainLoop<CanWorkerState> for CanWorker<Recovery>  {
    fn main_loop(self) -> CanWorkerState {
        panic!("CanWorker does not implement recovery");
    }
}
impl MainLoop<CanWorkerState> for CanWorker<Connected> {
    fn main_loop(self) -> CanWorkerState {
        panic!("CanWorker does not implement connected");
    }
}
impl MainLoop<CanWorkerState> for CanWorker<Disconnected> {
 fn main_loop(mut self) -> CanWorkerState {
    let response = self.can_handle.read_frame(); // with timeout
    if response.should_retry() {
        // Timeout with no message
        println!("CAN SOCKET: Read timeout no message Received");
    } else if let Ok(frame) = response {
        // Frame Received
        // Check for state messages before passing the frame on to the worker
        match frame.get_command() {
            CanCommand::BmsStateChange(ack_nack) => {
                // println!("BMS STATE CHANGE ACC, {:?}", self.requested_pod_state);
                match ack_nack {
                    AckNack::Ack => {
                        self.board_state.set_bms_state(&self.requested_pod_state);
                    }
                    _ => panic!("Received A NACK FROM BMS State Change. Don't know what to do!")
                }
            },
            CanCommand::MotorControllerStateChange(ack_nack) => {
                // println!("MC STATE CHANGE ACC, {:?}", self.requested_pod_state);
                match ack_nack {
                    AckNack::Ack => {
                        self.board_state.set_motor_controller_state(&self.requested_pod_state);
                    }
                    _ => panic!("Received A NACK FROM MotorController State Change. Don't know what to do!")
                }
            },
            CanCommand::PressureStateChange(ack_nack) => {
                match ack_nack {
                    AckNack::Ack => {
                        self.board_state.set_pressure_state(&self.requested_pod_state);
                    }
                    _ => panic!("Received A NACK FROM MotorController State Change. Don't know what to do!")
                }
            }
            _ => {}
        }
        self.worker_sender.send(WorkerMessage::CanFrameAndTimeStamp(frame, chrono::Utc::now().naive_local())).expect("Unable to send message from CAN Thread on Worker Channel");
    } else {
        // ERROR Reading from Can socket
        println!("Error Reading from CAN Socket");
    }

    // Check for Transition Complete
    if *self.board_state.get_bms_state() == self.requested_pod_state
    && *self.board_state.get_pressure_state() == self.requested_pod_state
    // && *self.board_state.get_motor_controller_state() == self.requested_pod_state // NO MOTOR CONTROLLER
    && self.requested_pod_state != self.current_pod_state {
        println!("Sending Ack to UDP for state change");
        self.current_pod_state = self.requested_pod_state;
        self.udp_sender.send(UDPMessage::PodStateChangeAck).expect("unable to message UDP thread");
    } else {
        println!("CURRENT {:?}, BMS: {:?}, PYSDUCK: {:?}, REQUESTED: {:?}", self.current_pod_state, self.board_state.get_bms_state(), self.board_state.get_pressure_state(), self.requested_pod_state);
    }

    // check for state message from udp or timeout from worker
    if let Ok(message) = self.can_receiver.try_recv() {
        match message {
            CanMessage::ChangeState(new_state) => {
                /* This check is just for safety. Since we deal with multiple workers, there could be race conditions. If DeviceLost is received, that needs to be the final state. */
                if self.requested_pod_state != PodState::SystemFailure {
                    self.requested_pod_state = new_state;
                }
            }
            CanMessage::DeviceLost => {
                self.requested_pod_state = PodState::SystemFailure;
                self.udp_sender.send(UDPMessage::SystemFault).unwrap();
            },
            CanMessage::BrakingTimerTimeout => {
                if self.current_pod_state == PodState::AutoPilot {
                    self.requested_pod_state = PodState::Braking;
                }
            }
        }
    }

    if self.last_send.elapsed().as_millis() >= 400 {
        self.last_send = Instant::now();
        let message_result = self.can_handle.send_pod_state(&self.requested_pod_state);

        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }

        /* ROBOT EQ Data queries */
        let message_result = self.can_handle.roboteq_read_battery_amps(1, 1);
        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }
        let message_result = self.can_handle.roboteq_read_battery_amps(1, 2);
        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }
        let message_result = self.can_handle.roboteq_read_encoder_motor_speed(1, 1);
        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }
        let message_result = self.can_handle.roboteq_read_encoder_motor_speed(1, 2);
        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }
        let message_result = self.can_handle.roboteq_read_temps(1);
        match message_result {
            Ok(()) => {},
            Err(err) => {
                println!("Error Sending Message on CAN bus: {:?}",  err);
            }
        }

        /* SEND GO MESSAGE TO ROBOTEQ */
        if self.current_pod_state == self.requested_pod_state && self.current_pod_state == PodState::AutoPilot {
            let node_id = 1;
            let max_motors = 1;
            let throttle_percent = 100;
            let message_result = self.can_handle.set_motor_throttle(node_id, max_motors, throttle_percent);

            match message_result {
                Ok(()) => {},
                Err(err) => {
                    println!("Error Sending Message on CAN bus: {:?}",  err);
                }
            }
        }

        /* TURN OFF ROBOTEQ with EBREAK */
        if self.requested_pod_state == PodState::SystemFailure {
            let message_result = self.can_handle.roboteq_emergency_stop(1);
            match message_result {
                Ok(()) => {},
                Err(err) => {
                    println!("Error Sending Message on CAN bus: {:?}",  err);
                }
            }
        }


    }
    CanWorkerState::Disconnected(self)
 }
}
